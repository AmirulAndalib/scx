diff --git a/Cargo.lock b/Cargo.lock
index 3d74a5b2..ed4a06b7 100644
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -1546,6 +1546,28 @@ version = "2.0.6"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f4c7245a08504955605670dbf141fceab975f15ca21570696aebe9d2e71576bd"
 
+[[package]]
+name = "inotify"
+version = "0.11.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f37dccff2791ab604f9babef0ba14fbe0be30bd368dc541e2b08d07c8aa908f3"
+dependencies = [
+ "bitflags 2.9.1",
+ "futures-core",
+ "inotify-sys",
+ "libc",
+ "tokio",
+]
+
+[[package]]
+name = "inotify-sys"
+version = "0.1.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e05c02b5e89bff3b946cedeca278abc628fe811e604f027c45a8aa3cf793d0eb"
+dependencies = [
+ "libc",
+]
+
 [[package]]
 name = "instability"
 version = "0.3.7"
@@ -2888,6 +2910,7 @@ dependencies = [
  "ctrlc",
  "fastrand",
  "fb_procfs",
+ "inotify",
  "lazy_static",
  "libbpf-rs",
  "libc",
diff --git a/scheds/rust/scx_layered/src/main.rs b/scheds/rust/scx_layered/src/main.rs
index b0cb2e85..f247062a 100644
--- a/scheds/rust/scx_layered/src/main.rs
+++ b/scheds/rust/scx_layered/src/main.rs
@@ -1590,6 +1590,9 @@ struct Scheduler<'a> {
     proc_reader: fb_procfs::ProcReader,
     sched_stats: Stats,
 
+    // Cgroup regex rules with sequential IDs
+    cgroup_regexes: Vec<(usize, Regex)>,
+
     nr_layer_cpus_ranges: Vec<(usize, usize)>,
     processing_dur: Duration,
 
@@ -1600,6 +1603,28 @@ struct Scheduler<'a> {
 }
 
 impl<'a> Scheduler<'a> {
+    fn collect_cgroup_regexes(layer_specs: &[LayerSpec]) -> Result<Vec<(usize, Regex)>> {
+        let mut cgroup_regexes = Vec::new();
+        let mut rule_id = 0;
+
+        for spec in layer_specs {
+            for match_ors in &spec.matches {
+                for layer_match in match_ors {
+                    if let LayerMatch::CgroupRegex(regex_str) = layer_match {
+                        let regex = Regex::new(regex_str).with_context(|| {
+                            format!("Invalid regex in layer {}: {}", spec.name, regex_str)
+                        })?;
+                        cgroup_regexes.push((rule_id, regex));
+                        info!("Registered cgroup regex rule ID {}: {}", rule_id, regex_str);
+                        rule_id += 1;
+                    }
+                }
+            }
+        }
+
+        Ok(cgroup_regexes)
+    }
+
     fn init_layers(skel: &mut OpenBpfSkel, specs: &[LayerSpec], topo: &Topology) -> Result<()> {
         skel.maps.rodata_data.as_mut().unwrap().nr_layers = specs.len() as u32;
         let mut perf_set = false;
@@ -1627,7 +1652,8 @@ impl<'a> Scheduler<'a> {
                             copy_into_cstr(&mut mt.cgroup_suffix, suffix.as_str());
                         }
                         LayerMatch::CgroupRegex(_) => {
-                            panic!("CgroupRegex match only supported in template");
+                            // CgroupRegex is now handled in userspace via the cgroup watcher
+                            // Skip BPF setup for this match type
                         }
                         LayerMatch::CgroupContains(substr) => {
                             mt.kind = bpf_intf::layer_match_kind_MATCH_CGROUP_CONTAINS as i32;
@@ -2482,6 +2508,9 @@ impl<'a> Scheduler<'a> {
             }
         }
 
+        // Collect CgroupRegex rules with sequential IDs
+        let cgroup_regexes = Self::collect_cgroup_regexes(&layer_specs)?;
+
         // Attach.
         let struct_ops = scx_ops_attach!(skel, layered)?;
         let stats_server = StatsServer::new(stats::server_data()).launch()?;
@@ -2501,6 +2530,7 @@ impl<'a> Scheduler<'a> {
 
             sched_stats: Stats::new(&mut skel, &proc_reader, &gpu_task_handler)?,
 
+            cgroup_regexes,
             nr_layer_cpus_ranges: vec![(0, 0); nr_layers],
             processing_dur: Default::default(),
 
@@ -3178,6 +3208,9 @@ impl<'a> Scheduler<'a> {
         // Also recursively watch existing directories for new subdirectories
         self.add_recursive_watches(&mut inotify, &mut wd_to_path, Path::new("/sys/fs/cgroup"))?;
 
+        // Clone regexes for the thread
+        let cgroup_regexes = self.cgroup_regexes.clone();
+
         // Spawn watcher thread
         std::thread::spawn(move || {
             let mut buffer = [0; 4096];
@@ -3220,6 +3253,14 @@ impl<'a> Scheduler<'a> {
 
                         info!("New cgroup created: {}", path.display());
 
+                        // Check if the new cgroup matches any regex rules
+                        let path_str = path.to_string_lossy();
+                        for (rule_id, regex) in &cgroup_regexes {
+                            if regex.is_match(&path_str) {
+                                info!("Cgroup {} matches regex rule ID {}", path_str, rule_id);
+                            }
+                        }
+
                         // Add watch for this new directory
                         match inotify
                             .watches()
