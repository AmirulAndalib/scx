// Simple EDF scheduler automaticatically generated by ChatGPT from the scx_rustland_core
// README.md, asking to generate an EDF scheduler using this framework and providing some
// abstracted guidance on how to evaluate the deadlines and task's time slice.
//
// The goal of this scheduler is to prove the ease of use of scx_rustland_core and it should not be
// considered a production-ready scheduler.

// This software may be used and distributed according to the terms of the
// GNU General Public License version 2.

mod bpf_skel;
pub use bpf_skel::*;
pub mod bpf_intf;

mod bpf;
use bpf::*;

use scx_utils::UserExitInfo;

use libbpf_rs::OpenObject;

use std::mem::MaybeUninit;
use std::collections::BinaryHeap;
use std::collections::HashMap;
use std::time::SystemTime;

use anyhow::Result;

const BASE_SLICE_NS: u64 = 5_000_000; // Base time slice in nanoseconds
const MIN_SLICE_NS: u64 = 1_000_000;  // Minimum time slice in nanoseconds
const DISPATCH_RATE_FACTOR: f64 = 100.0;

/// Represents a task with its deadline for EDF scheduling.
#[derive(Debug, PartialEq, Eq)]
struct EDFTask {
    deadline: u64,
    task: QueuedTask,
}

impl Ord for EDFTask {
    fn cmp(&self, other: &Self) -> std::cmp::Ordering {
        other.deadline.cmp(&self.deadline)
    }
}

impl PartialOrd for EDFTask {
    fn partial_cmp(&self, other: &Self) -> Option<std::cmp::Ordering> {
        Some(self.cmp(other))
    }
}

struct Scheduler<'a> {
    bpf: BpfScheduler<'a>,
    task_queue: BinaryHeap<EDFTask>,
    last_execution_time: HashMap<i32, u64>, // Tracks the last execution time of each task
    last_sum_exec_runtime: HashMap<i32, u64>,   // Tracks the last sum_exec_runtime of each task
    dispatch_count: HashMap<i32, u64>,          // Tracks the number of dispatches per task
    dispatch_start_time: HashMap<i32, u64>, // Tracks the start time for dispatch rate calculation
    dispatch_rate: HashMap<i32, f64>,           // Stores the dispatch rate (dispatches per second) for each task
}

impl<'a> Scheduler<'a> {
    fn init(open_object: &'a mut MaybeUninit<OpenObject>) -> Result<Self> {
        let bpf = BpfScheduler::init(
            open_object,
            0,     // exit_dump_len
            false, // partial
            false, // debug
        )?;
        Ok(Self {
            bpf,
            task_queue: BinaryHeap::new(),
            last_execution_time: HashMap::new(),
            last_sum_exec_runtime: HashMap::new(),
            dispatch_count: HashMap::new(),
            dispatch_start_time: HashMap::new(),
            dispatch_rate: HashMap::new(),
        })
    }

    fn now() -> u64 {
        let ts = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .unwrap();
        ts.as_nanos() as u64
    }

    fn consume_all_tasks(&mut self) {
        while let Ok(Some(task)) = self.bpf.dequeue_task() {
            let now = Self::now();
            let last_exec_time = self.last_execution_time.get(&task.pid).cloned().unwrap_or(now);
            let last_sum_exec_runtime = self.last_sum_exec_runtime.get(&task.pid).cloned().unwrap_or(0);

            // Compute the new deadline using task weight and a slice bonus in function of the
            // dispatch rate
            let time_slice_duration = self.calculate_time_slice(task.sum_exec_runtime, last_sum_exec_runtime, task.weight);
            let time_slice_bonus = (self.get_dispatch_rate(task.pid) * DISPATCH_RATE_FACTOR * BASE_SLICE_NS as f64) as u64;
            let deadline = last_exec_time + time_slice_duration - time_slice_bonus;

            // Enqueue the task with its calculated deadline
            self.task_queue.push(EDFTask { deadline, task });
        }
    }

    fn calculate_time_slice(&self, current_sum_exec_runtime: u64, last_sum_exec_runtime: u64, weight: u64) -> u64 {
        // Determine the effective time slice for the task, clamping it to BASE_SLICE_NS
        let effective_time_slice = (current_sum_exec_runtime - last_sum_exec_runtime).min(BASE_SLICE_NS);

        // Scale the time slice by the task weight, with a scaling factor
        let weighted_time_slice = effective_time_slice as f64 * 100.0 / (weight as f64);

        weighted_time_slice as u64
    }

    fn get_dispatch_rate(&self, pid: i32) -> f64 {
        *self.dispatch_rate.get(&pid).unwrap_or(&0.0)
    }

    fn dispatch_next_task(&mut self) {
        if let Some(EDFTask { deadline, task }) = self.task_queue.pop() {
            let mut dispatched_task = DispatchedTask::new(&task);

            let cpu = self.bpf.select_cpu(task.pid, task.cpu, 0);
            if cpu >= 0 {
                dispatched_task.cpu = cpu;
            } else {
                dispatched_task.flags |= RL_CPU_ANY;
            }

            let waiting_tasks = self.task_queue.len() as u64 + 1;
            let slice_ns = BASE_SLICE_NS / waiting_tasks;
            dispatched_task.slice_ns = slice_ns.max(MIN_SLICE_NS);
            dispatched_task.vtime = deadline;

            self.bpf.dispatch_task(&dispatched_task).unwrap();

            // Update the last execution time for the task
            let current_time = Self::now();
            self.last_execution_time.insert(task.pid, current_time);
            self.last_sum_exec_runtime.insert(task.pid, task.sum_exec_runtime);

            // Increment the dispatch count
            let count = self.dispatch_count.entry(task.pid).or_insert(0);
            *count += 1;

            // Initialize the start time for rate calculation if not already present
            let start_time = self.dispatch_start_time.entry(task.pid).or_insert(current_time);

            // Calculate the elapsed time and dispatch rate
            let elapsed_secs = current_time - *start_time;
            if elapsed_secs > 1_000_000 {
                let prev_rate = *self.dispatch_rate.get(&task.pid).unwrap_or(&0.0);
                let curr_rate = *count as f64 / elapsed_secs as f64 * 1_000_000 as f64;
                let avg_rate = prev_rate * 0.75 + curr_rate * 0.25;
                self.dispatch_rate.insert(task.pid, avg_rate);

                // Reset start time and dispatch counter
                *start_time = current_time;
                *count = 0;
            }

            self.bpf.notify_complete(self.task_queue.len() as u64);
        }
    }

    fn dispatch_tasks(&mut self) {
        loop {
            self.consume_all_tasks();
            self.dispatch_next_task();

            if self.task_queue.is_empty() {
                self.bpf.notify_complete(0);
                break;
            }
        }
    }

    fn run(&mut self) -> Result<UserExitInfo> {
        println!("scheduler is running");
        while !self.bpf.exited() {
            self.dispatch_tasks();
        }
        self.bpf.shutdown_and_report()
    }
}

fn main() -> Result<()> {
    // Initialize and load the EDF scheduler.
    let mut open_object = MaybeUninit::uninit();
    loop {
        let mut sched = Scheduler::init(&mut open_object)?;
        if !sched.run()?.should_restart() {
            break;
        }
    }

    Ok(())
}

